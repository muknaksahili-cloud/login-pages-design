import * as i0 from '@angular/core';
import { AfterContentInit, OnChanges, EventEmitter, SimpleChanges, ElementRef } from '@angular/core';
import { Observable } from 'rxjs';

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

declare class NzResizeObserverDirective implements AfterContentInit, OnChanges {
    private nzResizeObserver;
    private elementRef;
    private destroyRef;
    readonly nzResizeObserve: EventEmitter<ResizeObserverEntry[]>;
    nzResizeObserverDisabled: boolean;
    private currentSubscription;
    private subscribe;
    private unsubscribe;
    constructor();
    ngAfterContentInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzResizeObserverDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NzResizeObserverDirective, "[nzResizeObserver]", never, { "nzResizeObserverDisabled": { "alias": "nzResizeObserverDisabled"; "required": false; }; }, { "nzResizeObserve": "nzResizeObserve"; }, never, never, true, never>;
    static ngAcceptInputType_nzResizeObserverDisabled: unknown;
}

declare class NzResizeObserverModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<NzResizeObserverModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NzResizeObserverModule, never, [typeof NzResizeObserverDirective], [typeof NzResizeObserverDirective]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NzResizeObserverModule>;
}

/**
 * Factory that creates a new ResizeObserver and allows us to stub it out in unit tests.
 */
declare class NzResizeObserverFactory {
    create(callback: ResizeObserverCallback): ResizeObserver | null;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzResizeObserverFactory, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NzResizeObserverFactory>;
}
/** An injectable service that allows watching elements for changes to their content. */
declare class NzResizeObserver {
    private nzResizeObserverFactory;
    private destroyRef;
    /** Keeps track of the existing ResizeObservers so they can be reused. */
    private observedElements;
    constructor();
    observe(elementOrRef: Element | ElementRef<Element>): Observable<ResizeObserverEntry[]>;
    /**
     * Observes the given element by using the existing ResizeObserver if available, or creating a
     * new one if not.
     */
    private observeElement;
    /**
     * Un-observes the given element and cleans up the underlying ResizeObserver if nobody else is
     * observing this element.
     */
    private unobserveElement;
    /** Clean up the underlying ResizeObserver for the specified element. */
    private cleanupObserver;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzResizeObserver, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NzResizeObserver>;
}

export { NzResizeObserver, NzResizeObserverDirective, NzResizeObserverFactory, NzResizeObserverModule };
