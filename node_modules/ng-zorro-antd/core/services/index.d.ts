import { Observable, Subject } from 'rxjs';
import * as i0 from '@angular/core';
import { OnDestroy } from '@angular/core';
import { NzSafeAny } from 'ng-zorro-antd/core/types';

declare class NzResizeService {
    private ngZone;
    private destroyRef;
    private readonly resizeSource$;
    private listeners;
    private renderer;
    private disposeHandle;
    private handler;
    constructor();
    connect(): Observable<void>;
    disconnet(): void;
    private registerListener;
    private unregisterListener;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzResizeService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NzResizeService>;
}

/**
 * Some singletons should have life cycle that is same to Angular's. This service make sure that
 * those singletons get destroyed in HMR.
 */
declare class NzSingletonService {
    private get singletonRegistry();
    /**
     * This registry is used to register singleton in dev mode.
     * So that singletons get destroyed when hot module reload happens.
     *
     * This works in prod mode too but with no specific effect.
     */
    private _singletonRegistry;
    registerSingletonWithKey(key: string, target: NzSafeAny): void;
    unregisterSingletonWithKey(key: string): void;
    getSingletonWithKey<T>(key: string): T | null;
    private withNewTarget;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzSingletonService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NzSingletonService>;
}

interface Point {
    x: number;
    y: number;
}
type Delta = Point;
/**
 * This module provide a global dragging service to other components.
 */
declare class NzDragService {
    private draggingThreshold;
    private currentDraggingSequence;
    private currentStartingPoint;
    private handleRegistry;
    private renderer;
    requestDraggingSequence(event: MouseEvent | TouchEvent): Observable<Delta>;
    private registerDraggingHandler;
    private teardownDraggingSequence;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzDragService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NzDragService>;
}

type EasyingFn = (t: number, b: number, c: number, d: number) => number;
interface NzScrollToOptions {
    /** Scroll container, default as window */
    easing?: EasyingFn;
    /** Scroll end callback */
    callback?(): void;
    /** Animation duration, default as 450 */
    duration?: number;
}
declare class NzScrollService {
    private doc;
    private ngZone;
    /** Set the position of the scroll bar of `el`. */
    setScrollTop(el: Element | Window, topValue?: number): void;
    /** Get position of `el` against window. */
    getOffset(el: Element): {
        top: number;
        left: number;
    };
    /** Get the position of the scoll bar of `el`. */
    getScroll(target?: Element | HTMLElement | Window | Document | null, top?: boolean): number;
    isWindow(obj: NzSafeAny): boolean;
    /**
     * Scroll `el` to some position with animation.
     *
     * @param containerEl container, `window` by default
     * @param y Scroll to `top`, 0 by default
     * @param options Scroll animation options
     */
    scrollTo(containerEl?: Element | HTMLElement | Window | Document | null, y?: number, options?: NzScrollToOptions): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzScrollService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NzScrollService>;
}

declare enum NzBreakpointEnum {
    xxl = "xxl",
    xl = "xl",
    lg = "lg",
    md = "md",
    sm = "sm",
    xs = "xs"
}
type BreakpointMap = Record<NzBreakpointEnum, string>;
type BreakpointBooleanMap = Record<NzBreakpointEnum, boolean>;
type NzBreakpointKey = keyof typeof NzBreakpointEnum;
declare const gridResponsiveMap: BreakpointMap;
declare const siderResponsiveMap: BreakpointMap;
declare class NzBreakpointService {
    private resizeService;
    private mediaMatcher;
    constructor();
    subscribe(breakpointMap: BreakpointMap): Observable<NzBreakpointEnum>;
    subscribe(breakpointMap: BreakpointMap, fullMap: true): Observable<BreakpointBooleanMap>;
    private matchMedia;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzBreakpointService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NzBreakpointService>;
}

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

declare class NzDestroyService extends Subject<void> implements OnDestroy {
    ngOnDestroy(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzDestroyService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NzDestroyService>;
}

interface PreloadOption {
    src: string;
    srcset?: string;
}
type PreloadDisposeHandle = () => void;
declare class ImagePreloadService {
    private counter;
    private linkRefs;
    private document;
    private platform;
    addPreload(option: PreloadOption): PreloadDisposeHandle;
    private appendPreloadLink;
    private removePreloadLink;
    static ɵfac: i0.ɵɵFactoryDeclaration<ImagePreloadService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ImagePreloadService>;
}

export { ImagePreloadService, NzBreakpointEnum, NzBreakpointService, NzDestroyService, NzDragService, NzResizeService, NzScrollService, NzSingletonService, gridResponsiveMap, siderResponsiveMap };
export type { BreakpointBooleanMap, BreakpointMap, EasyingFn, NzBreakpointKey, NzScrollToOptions, PreloadDisposeHandle };
