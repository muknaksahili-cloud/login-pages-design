import * as i0 from '@angular/core';
import { OnInit, AfterViewInit, OnChanges, ElementRef, TemplateRef, EventEmitter, SimpleChanges } from '@angular/core';
import { NzQRCodeI18nInterface } from 'ng-zorro-antd/i18n';

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */
declare namespace qrcodegen {
    type bit = number;
    type byte = number;
    type int = number;
    export class QrCode {
        readonly version: int;
        readonly errorCorrectionLevel: QrCode.Ecc;
        static encodeText(text: string, ecl: QrCode.Ecc): QrCode;
        static encodeBinary(data: readonly byte[], ecl: QrCode.Ecc): QrCode;
        static encodeSegments(segs: readonly QrSegment[], ecl: QrCode.Ecc, minVersion?: int, maxVersion?: int, mask?: int, boostEcl?: boolean): QrCode;
        readonly size: int;
        readonly mask: int;
        private readonly modules;
        private readonly isFunction;
        constructor(version: int, errorCorrectionLevel: QrCode.Ecc, dataCodewords: readonly byte[], msk: int);
        getModule(x: int, y: int): boolean;
        getModules(): boolean[][];
        private drawFunctionPatterns;
        private drawFormatBits;
        private drawVersion;
        private drawFinderPattern;
        private drawAlignmentPattern;
        private setFunctionModule;
        private addEccAndInterleave;
        private drawCodewords;
        private applyMask;
        private getPenaltyScore;
        private getAlignmentPatternPositions;
        private static getNumRawDataModules;
        private static getNumDataCodewords;
        private static reedSolomonComputeDivisor;
        private static reedSolomonComputeRemainder;
        private static reedSolomonMultiply;
        private finderPenaltyCountPatterns;
        private finderPenaltyTerminateAndCount;
        private finderPenaltyAddHistory;
        static readonly MIN_VERSION: int;
        static readonly MAX_VERSION: int;
        private static readonly PENALTY_N1;
        private static readonly PENALTY_N2;
        private static readonly PENALTY_N3;
        private static readonly PENALTY_N4;
        private static readonly ECC_CODEWORDS_PER_BLOCK;
        private static readonly NUM_ERROR_CORRECTION_BLOCKS;
    }
    export class QrSegment {
        readonly mode: QrSegment.Mode;
        readonly numChars: int;
        private readonly bitData;
        static makeBytes(data: readonly byte[]): QrSegment;
        static makeNumeric(digits: string): QrSegment;
        static makeAlphanumeric(text: string): QrSegment;
        static makeSegments(text: string): QrSegment[];
        static makeEci(assignVal: int): QrSegment;
        static isNumeric(text: string): boolean;
        static isAlphanumeric(text: string): boolean;
        constructor(mode: QrSegment.Mode, numChars: int, bitData: bit[]);
        getData(): bit[];
        static getTotalBits(segs: readonly QrSegment[], version: int): number;
        private static toUtf8ByteArray;
        private static readonly NUMERIC_REGEX;
        private static readonly ALPHANUMERIC_REGEX;
        private static readonly ALPHANUMERIC_CHARSET;
    }
    export {};
}
declare namespace qrcodegen {
    namespace QrCode {
        type int = number;
        export class Ecc {
            readonly ordinal: int;
            readonly formatBits: int;
            static readonly LOW: Ecc;
            static readonly MEDIUM: Ecc;
            static readonly QUARTILE: Ecc;
            static readonly HIGH: Ecc;
            private constructor();
        }
        export {};
    }
}
declare namespace qrcodegen {
    namespace QrSegment {
        type int = number;
        export class Mode {
            readonly modeBits: int;
            private readonly numBitsCharCount;
            static readonly NUMERIC: Mode;
            static readonly ALPHANUMERIC: Mode;
            static readonly BYTE: Mode;
            static readonly KANJI: Mode;
            static readonly ECI: Mode;
            private constructor();
            numCharCountBits(ver: int): int;
        }
        export {};
    }
}

/**
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE
 */

declare const ERROR_LEVEL_MAP: Record<'L' | 'M' | 'Q' | 'H', qrcodegen.QrCode.Ecc>;

declare class NzQRCodeComponent implements OnInit, AfterViewInit, OnChanges {
    private i18n;
    private el;
    private cdr;
    private destroyRef;
    protected isBrowser: boolean;
    canvas: ElementRef<HTMLCanvasElement>;
    nzValue: string;
    nzPadding: number | number[];
    nzColor: string;
    nzBgColor: string;
    nzSize: number;
    nzIcon: string;
    nzIconSize: number;
    nzBordered: boolean;
    nzStatus: 'active' | 'expired' | 'loading' | 'scanned';
    nzLevel: keyof typeof ERROR_LEVEL_MAP;
    nzStatusRender?: TemplateRef<void> | string | null;
    readonly nzRefresh: EventEmitter<string>;
    locale: NzQRCodeI18nInterface;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngAfterViewInit(): void;
    reloadQRCode(): void;
    drawCanvasQRCode(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NzQRCodeComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NzQRCodeComponent, "nz-qrcode", ["nzQRCode"], { "nzValue": { "alias": "nzValue"; "required": false; }; "nzPadding": { "alias": "nzPadding"; "required": false; }; "nzColor": { "alias": "nzColor"; "required": false; }; "nzBgColor": { "alias": "nzBgColor"; "required": false; }; "nzSize": { "alias": "nzSize"; "required": false; }; "nzIcon": { "alias": "nzIcon"; "required": false; }; "nzIconSize": { "alias": "nzIconSize"; "required": false; }; "nzBordered": { "alias": "nzBordered"; "required": false; }; "nzStatus": { "alias": "nzStatus"; "required": false; }; "nzLevel": { "alias": "nzLevel"; "required": false; }; "nzStatusRender": { "alias": "nzStatusRender"; "required": false; }; }, { "nzRefresh": "nzRefresh"; }, never, never, true, never>;
    static ngAcceptInputType_nzSize: unknown;
    static ngAcceptInputType_nzIconSize: unknown;
    static ngAcceptInputType_nzBordered: unknown;
}

declare class NzQRCodeModule {
    static ɵfac: i0.ɵɵFactoryDeclaration<NzQRCodeModule, never>;
    static ɵmod: i0.ɵɵNgModuleDeclaration<NzQRCodeModule, never, [typeof NzQRCodeComponent], [typeof NzQRCodeComponent]>;
    static ɵinj: i0.ɵɵInjectorDeclaration<NzQRCodeModule>;
}

export { NzQRCodeComponent, NzQRCodeModule };
