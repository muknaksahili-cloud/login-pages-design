import { HttpClient, HttpBackend } from '@angular/common/http';
import * as i0 from '@angular/core';
import { InjectionToken, Renderer2, RendererFactory2, OnChanges, ElementRef, SimpleChanges, EnvironmentProviders } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { Observable } from 'rxjs';

interface IconDefinition {
    name: string;
    theme?: ThemeType | undefined;
    icon: string;
}
type ThemeType = 'fill' | 'outline' | 'twotone';
interface Manifest {
    fill: string[];
    outline: string[];
    twotone: string[];
}
interface CachedIconDefinition {
    name: string;
    theme: string;
    icon: SVGElement;
}
interface TwoToneColorPaletteSetter {
    primaryColor: string;
    secondaryColor?: string;
}
interface TwoToneColorPalette extends TwoToneColorPaletteSetter {
    secondaryColor: string;
}

declare const ANT_ICONS: InjectionToken<IconDefinition[]>;
declare class IconService {
    protected _antIcons: IconDefinition[];
    defaultTheme: ThemeType;
    set twoToneColor({ primaryColor, secondaryColor }: TwoToneColorPaletteSetter);
    get twoToneColor(): TwoToneColorPaletteSetter;
    protected _renderer: Renderer2;
    protected _http: HttpClient;
    /**
     * Disable dynamic loading (support static loading only).
     */
    protected get _disableDynamicLoading(): boolean;
    /**
     * All icon definitions would be registered here.
     */
    protected readonly _svgDefinitions: Map<string, IconDefinition>;
    /**
     * Cache all rendered icons. Icons are identified by name, theme,
     * and for twotone icons, primary color and secondary color.
     */
    protected readonly _svgRenderedDefinitions: Map<string, CachedIconDefinition>;
    protected _inProgressFetches: Map<string, Observable<IconDefinition | null>>;
    /**
     * Url prefix for fetching inline SVG by dynamic importing.
     */
    protected _assetsUrlRoot: string;
    protected _twoToneColorPalette: TwoToneColorPalette;
    /** A flag indicates whether jsonp loading is enabled. */
    private _enableJsonpLoading;
    private readonly _jsonpIconLoad$;
    protected _rendererFactory: RendererFactory2;
    protected _handler: HttpBackend | null;
    protected _document: Document;
    protected sanitizer: DomSanitizer;
    constructor(_antIcons: IconDefinition[]);
    /**
     * Call this method to switch to jsonp like loading.
     */
    useJsonpLoading(): void;
    /**
     * Change the prefix of the inline svg resources, so they could be deployed elsewhere, like CDN.
     * @param prefix
     */
    changeAssetsSource(prefix: string): void;
    /**
     * Add icons provided by ant design.
     * @param icons
     */
    addIcon(...icons: IconDefinition[]): void;
    /**
     * Register an icon. Namespace is required.
     * @param type
     * @param literal
     */
    addIconLiteral(type: string, literal: string): void;
    /**
     * Remove all cache.
     */
    clear(): void;
    /**
     * Get a rendered `SVGElement`.
     * @param icon
     * @param twoToneColor
     */
    getRenderedContent(icon: IconDefinition | string, twoToneColor?: string): Observable<SVGElement>;
    getCachedIcons(): Map<string, IconDefinition>;
    /**
     * Get raw svg and assemble a `IconDefinition` object.
     * @param type
     */
    protected _loadIconDynamically(type: string): Observable<IconDefinition | null>;
    protected _loadIconDynamicallyWithJsonp(icon: IconDefinition, url: string): Observable<IconDefinition>;
    /**
     * Render a new `SVGElement` for a given `IconDefinition`, or make a copy from cache.
     * @param icon
     * @param twoToneColor
     */
    protected _loadSVGFromCacheOrCreateNew(icon: IconDefinition, twoToneColor?: string): SVGElement;
    protected _createSVGElementFromString(str: string): SVGElement;
    protected _setSVGAttribute(svg: SVGElement): SVGElement;
    protected _colorizeSVGIcon(svg: SVGElement, twotone: boolean, pri: string, sec: string): SVGElement;
    static ɵfac: i0.ɵɵFactoryDeclaration<IconService, [{ optional: true; }]>;
    static ɵprov: i0.ɵɵInjectableDeclaration<IconService>;
}

interface RenderMeta {
    type: string | IconDefinition;
    theme?: ThemeType;
    twoToneColor?: string;
}
declare class IconDirective implements OnChanges {
    protected _iconService: IconService;
    type: string | IconDefinition;
    theme?: ThemeType;
    twoToneColor?: string;
    protected _elementRef: ElementRef<any>;
    protected _renderer: Renderer2;
    constructor(_iconService: IconService);
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * Render a new icon in the current element. Remove the icon when `type` is falsy.
     */
    protected _changeIcon(): Promise<SVGElement | null>;
    protected _getSelfRenderMeta(): RenderMeta;
    /**
     * Parse a icon to the standard form, an `IconDefinition` or a string like 'account-book-fill` (with a theme suffixed).
     * If namespace is specified, ignore theme because it meaningless for users' icons.
     *
     * @param type
     * @param theme
     */
    protected _parseIconType(type: string | IconDefinition, theme?: ThemeType): IconDefinition | string;
    protected _setSVGElement(svg: SVGElement): void;
    protected _clearSVGElement(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<IconDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<IconDirective, "[antIcon]", never, { "type": { "alias": "type"; "required": false; }; "theme": { "alias": "theme"; "required": false; }; "twoToneColor": { "alias": "twoToneColor"; "required": false; }; }, {}, never, never, true, never>;
}

declare function NameSpaceIsNotSpecifyError(): Error;
declare function IconNotFoundError(icon: string): Error;
declare function HttpModuleNotImport(): null;
declare function UrlNotSafeError(url: string): Error;
declare function SVGTagNotFoundError(): Error;
declare function DynamicLoadingTimeoutError(): Error;

/**
 * Provide icon definitions in root
 *
 * @param icons Icon definitions
 */
declare function provideAntIcons(icons: IconDefinition[]): EnvironmentProviders;

declare const ANT_ICON_ANGULAR_CONSOLE_PREFIX = "[@ant-design/icons-angular]:";
declare function error(message: string): void;
declare function warn(message: string): void;
declare function getSecondaryColor(primaryColor: string): string;
declare function withSuffix(name: string, theme: ThemeType | undefined): string;
declare function withSuffixAndColor(name: string, theme: ThemeType, pri: string, sec: string): string;
declare function mapAbbrToTheme(abbr: string): ThemeType;
declare function alreadyHasAThemeSuffix(name: string): boolean;
declare function isIconDefinition(target: string | IconDefinition): target is IconDefinition;
/**
 * Get an `IconDefinition` object from abbreviation type, like `account-book-fill`.
 * @param str
 */
declare function getIconDefinitionFromAbbr(str: string): IconDefinition;
declare function cloneSVG(svg: SVGElement): SVGElement;
/**
 * Parse inline SVG string and replace colors with placeholders. For twotone icons only.
 */
declare function replaceFillColor(raw: string): string;
/**
 * Split a name with namespace in it into a tuple like [ name, namespace ].
 */
declare function getNameAndNamespace(type: string): [string, string];
declare function hasNamespace(type: string): boolean;

declare const manifest: Manifest;

export { ANT_ICONS, ANT_ICON_ANGULAR_CONSOLE_PREFIX, DynamicLoadingTimeoutError, HttpModuleNotImport, IconDirective, IconNotFoundError, IconService, NameSpaceIsNotSpecifyError, SVGTagNotFoundError, UrlNotSafeError, alreadyHasAThemeSuffix, cloneSVG, error, getIconDefinitionFromAbbr, getNameAndNamespace, getSecondaryColor, hasNamespace, isIconDefinition, manifest, mapAbbrToTheme, provideAntIcons, replaceFillColor, warn, withSuffix, withSuffixAndColor };
export type { CachedIconDefinition, IconDefinition, Manifest, ThemeType, TwoToneColorPalette, TwoToneColorPaletteSetter };
